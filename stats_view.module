<?php
// $Id$

/**
 * @file
 * Display usage statistics in various places
 * @author BÃ¨r Kessels <ber@webschuur.com>
 * @link http://wizzlern.nl
 * @package stats_view
 */

/* -----------------------------------------------------------------
  Hook Implementations
------------------------------------------------------------------ */
/**
 * Implementation of hook_perm().
 */
function stats_view_perm() {
  return array(
    'administer stats_view',
    'access usage statistics',
  );
}

/**
 * Implementation of hook_menu().
 */
function stats_view_menu() {
  $items = array();

  $items['admin/settings/stats_view'] = array(
    'title' => t('View statistics'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('stats_view_settings'),
    'access arguments' => array('administer stats_view'),
  );

  $items['stats_view_test'] = array(
    'title' => t('View statistics for a test-path'),
    'page callback' => 'stats_view_stats_test_page',
    'access arguments' => array('access usage statistics'),
  );

  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function stats_view_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'view':
      // Displaying a string when the node is viewed. 
      // This operation is called after the node has already been prepared
      // into HTML and filtered as necessary, so we know we are dealing with an
      // HTML teaser and body. We will inject our additional information at the front
      // of the node copy.
      //
      // Using nodeapi('view') is more appropriate than using a filter here, because
      // filters transform user-supplied content, whereas we are extending it with
      // additional information.

      //For "view", $a3 passes in the $teaser parameter from node_view().
      if (!$a3) {
        $node->content['stats_view'] = array(
          '#value' => stats_view_stats_test_page(),
          '#weight' => 4,
        );
      }

      break;
  }
}

/**
 * Implementation fof hook_theme()
 *
 * Register a module (or theme's) theme implementations.
 * Modules and themes implementing this return an array of arrays. The key to 
 * each sub-array is the internal name of the hook, and the array contains info 
 * about the hook.
 */
function stats_view_theme($existing, $type, $theme, $path) {

  $theme_functions =  array(
    'stats_test_page' => array(
      'arguments' => array('stats' => array()),
    ),
  );
  
  //var_dump($theme_functions); //Use this to investigate the structure more closely.
  
  return $theme_functions;
}

/**
 * Implementation of hook_block().
 *
 * This hook both declares to Drupal what blocks are provided by the module, and
 * generates the contents of the blocks themselves.
 */
function stats_view_block($op = 'list', $delta = 0, $edit = array()) {
  // The $op parameter determines what piece of information is being requested.
  switch ($op) {
    case 'list':
      // If $op is "list", we just need to return a list of block descriptions.
      // This is used to provide a list of possible blocks to the administrator,
      // end users will not see these descriptions.
      $blocks['top_paths'] = array(
        'info' => t('10 most visited paths.'),
      );
      // A block can provide default settings. In this case we'll enable the 
      // block.
      $blocks['log'] = array(
        'info' => t('Recent accesslogs for current page.'),
      );
      return $blocks;

    case 'view': default:
      // If $op is "view", then we need to generate the block for display
      // purposes. The $delta parameter tells us which block is being requested.
      switch ($delta) {
        case 'top_paths':
          // The subject is displayed at the top of the block. Note that it
          // should be passed through t() for translation.
          $block['subject'] = t('Top 10 paths');
          // The content of the block is typically generated by calling a custom
          // function.
          $block['content'] = '@TODO';
          break;
        case 'log':
          $block['subject'] = t('Accesslog');
          $block['content'] = stats_view_stats_test_page();
          break;
      }
      return $block;
  }
}


/**
 * callback for hook_menu().
 */
function stats_view_settings($form_state) {
  $form['stats_view_amount_entries'] = array(
    '#type' => 'textfield',
    '#title' => t('Amount of entries to show'),
    '#description' => t('Provide the amount of statistics-entries that you want to show in the block with the articles.'),
    '#default_value' => variable_get('stats_view_amount_entries', 5),
    '#weight' => 1,
  );

  return system_settings_form($form);
}

/**
 * Validation callback for stats_view_settings form.
 */
function stats_view_settings_validate($form, &$form_state) {
  //print_r($form_state);
  if (!(int)$form_state['values']['stats_view_amount_entries']) {
    form_set_error('stats_view_amount_entries', 'amount must be a round number');
  }
  elseif ($form_state['values']['stats_view_amount_entries'] <= 0) {
    form_set_error('stats_view_amount_entries', 'amount must be greater then 0');
  }
}

/**
 * Get a list of statistic items in the database.
 * We do not render any lists in this function. That would not be MVC.
 * Instead we only speak to the database. Nothing more. 
 * @param $path string Optional string of the path where we want the statistics for.
 *  If left empty, we determine the path ourselves and take the current path.
 */
function stats_view_stats_for_page($path = '') {
  $stats = array(); //It is good practice to always return the same (type of) value.
  
  //First see if we must determine the path.
  if (empty($path)) {
    //If we have not path defined, we simply check the Superglobal $GET. 
    // In Drupal the "path", whether or not you have clean-urls, is set in $GET['q'].
    // However, tipically you would use the function arg() to get a part from this path. 
    $path = $_GET['q']; //No need to escape. Drupals databaselayer does that for us.
  }
  
  // A replacement-token for a string is %s and for an integer %d.
  // Drupal will remove potential dangerous
  // SQL-injection stuff from this string. It will not sanitize it against XSS
  // exploits though!
  $result = db_query("SELECT * FROM accesslog a WHERE path LIKE '%s' ORDER BY timestamp DESC LIMIT %d", $path, variable_get('stats_view_amount_entries', 5));
  
  while ($row = db_fetch_object($result)) {
    $stats[] = $row;
  }
  
  return $stats;
}

/**
 * Test-page: a menu-callback that contains a call to stats_view_stats_for_page()
 * to check for the path "admin"
 */
function stats_view_stats_test_page() {
  $out = ''; 
  $prepared_stats = array();
  
  $stats = stats_view_stats_for_page();
  
  foreach ($stats as $row) {
    $prepared = new stdClass(); //reset the variable for each row.
    
    $prepared->date = format_date($row->timestamp);
    $prepared->hostname = check_plain($row->hostname);
    $prepared->path = check_plain($row->path);
    
    $prepared_stats[] = $prepared;
  }
 
  return theme('stats_test_page', $prepared_stats);
}

/**
 * Theme function to render a list of statistics entries.
 * @ingroup Theme
 */
function theme_stats_test_page($stats) {
  //It is good practice to not put logic like 'if (is_array())'in theme-functions. 
  //The code calling the theme_function should take care of such validations and logic. 
  // The only logic allowed in a good theme_function, is logic that supports 
  // rendering: e.g. to avoid empty <h3> tags we first check if a title is empty. 
  foreach ($stats as $row) {
    $items[] = "at ". $row->date ." host ". $row->hostname ." visited ". $row->path;
  }

  return theme('item_list', $items);
}

